<!DOCTYPE>
<html>
<head>
<title>Sky Hopper - Web Application for Sky Navigation</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
</head>
<style>
body { font-size: 5mm ; color:red ; font-family: sans; background-color:black }
button { height:10mm; font-size:5mm ; text-align:center; vertical-align: middle; background-color:black; color:red; border: 2px solid red }
.comp_but, .incdec_but { width: 10mm ; height:10mm; font-size:5mm ; padding: 0 }
.comp_but { float:right }
</style>
<body>
<canvas style="position:absolute; left:0; top:0; z-index:-1"  id="myCanvas" width="640" height="480"> </canvas>
<p>
		<button class="incdec_but" onclick="incFOV();">-</button>
		<button class="incdec_but" onclick="decFOV();">+</button>
		&angle;<span id="fov_val">60&deg;</span><span style="font-size:16px" id="rtime"></span>
		<span style="float:right">
			<button class="comp_but" style="color: transparent; text-shadow: 0 0 0 red;" onclick="showConfig('inline');">&#x2699;</button>
		</span>
</p>
<p>
		<button class="incdec_but" onclick="decMAG();">-</button>
		<button class="incdec_but" onclick="incMAG();">+</button>
		<i>m&leq;</i><span id="mag_val">4</span>
		<span style="float:right">
			<button class="incdec_but" onclick="resetAll();">&#x21bb;</button>
		</span>
</p>
<p>
	<button class="ui_but" onclick="align();">Align</button>
	<span id="alignment"></span> <span id="countdown"></span>
	<button class="comp_but" id="nocompass_button" style="display:none"><strike>&#x238b;</strike></button>
	<button class="comp_but" id="hand_button" style="display:none; color: transparent; text-shadow: 0 0 0 red;" onclick="manualMode();">&#x270B;</button>
	<button class="comp_but" id="compass_button" style="display:none" onclick="compassMode();">&#x238b;</button>
</p>
<p id="gps">No Geolocation</p>
<div id="object_log" style="display:none">
<p>Sirius:<span id="Sirius_alt"></span>, <span id="Sirius_az"></span></p>
<p>Mars:<span id="Mars_alt"></span>, <span id="Mars_az"></span></p>
<p>Rigel:<span id="Rigel_alt"></span>, <span id="Rigel_az"></span></p>
<p>Jupiter:<span id="Jupiter_alt"></span>, <span id="Jupiter_az"></span></p>
</div>
<p id="orient"></p>
<p id="status"></p>
<div class="config_div" id="allow_orientation" style="display:none; position:absolute; left:10%; top:10%; z-index:3 ; padding: 1% 1% 1% 1%; width: 78%; background:black; border: 1px solid red ; text-align:center ">
<button class="ui_but" style="height:30mm" onclick="iOSOrientation();">Enable Device Orientation</button>
</div>
<div class="config_div" id="config" style="display:none; position:absolute; left:5%; top:5%; z-index:2 ; padding: 1% 1% 1% 1%; width: 88%; background:black; border: 1px solid red ">
<button class="incdec_but" style="position:absolute; right:1mm; top:1mm" onclick="showConfig('none');">X</button>
<p><b>Settings (version)</b></p>
<p><input class="dso_selector" id="NM_checked" type="checkbox" onchange="switchNightMode(this.checked)" /><label for="NM_checked" >Night Mode</label></p>
<p><input class="dso_selector" id="FS_checked" type="checkbox" onchange="toggleFS(this.checked)"        /><label for="FS_checked" >Full Screen</label></p>
<p>
DSO Magnitude &leq;<span id="dso_level_val">5</span><br/>
<input style="width:100%" type="range" id="dso_level" name="dso_level" min="3" max="16" value="5" step="1" onchange="setDSOMag(this.value)" />
</p>
<p><input class="dso_selector" id="P_checked"  type="checkbox" checked="checked" onchange="global_show_obj.P  = this.checked;" /><label for="P_checked" >Planets</label></p>
<p><input class="dso_selector" id="Oc_checked" type="checkbox" checked="checked" onchange="global_show_obj.Oc = this.checked;" /><label for="Oc_checked">Clusters and Clouds</label></p>
<p><input class="dso_selector" id="Gc_checked" type="checkbox" checked="checked" onchange="global_show_obj.Gc = this.checked;" /><label for="Gc_checked">Globular Clusters</label></p>
<p><input class="dso_selector" id="Ga_checked" type="checkbox" checked="checked" onchange="global_show_obj.Ga = this.checked;" /><label for="Ga_checked">Galaxies</label></p>
<p><input class="dso_selector" id="Ne_checked" type="checkbox" checked="checked" onchange="global_show_obj.Ne = this.checked;" /><label for="Ne_checked">Nebulae</label></p>
<p><input class="dso_selector" id="Ca_checked" type="checkbox" checked="checked" onchange="global_show_obj.Ca = this.checked;" /><label for="Ca_checked">Constellations</label></p>
<hr>
<p><span id="lat"></span>, <span id="lon"></span></p>
<p>&#x03B1;=<span id="ang_a"></span> &#x03B2;=<span id="ang_b"></span> &#x03B3;=<span id="ang_g"></span> C=<span id="ang_c"></span></p>
</div>
<script src="vsop87-multilang/Languages/JavaScript/vsop87a_xsmall.js"></script>
<script>
vsop87a_full = vsop87a_xsmall;
</script>
<script src="vsop87-multilang/Languages/JavaScript/astrolib.js"></script>
<script src="jsdb.js"></script>
<script>

var global_day_style = {
	cross 		: 'blue',
	constelations 	: 'yellow',
	bearing 	: 'green',
	star		: 'white',
	altaz		: 'red',
	target		: 'cyan',
	align		: 'magenta'
};

var global_show_obj = {
	'S': true,
	'Oc': true,
	'Gc': true,
	'Ca': true,
	'Ga':true,
	'Ne':true,
    	'P': true,
};

var global_night_style = {
	cross 		: 'red',
	constelations 	: '#880000',
	bearing 	: 'red',
	star		: 'red',
	altaz		: 'red',
	target		: '#AA0000',
	align		: '#AA0000'
};



var global_style = global_day_style;

var global_targets_list = [];
var global_prev_xy=null;
var global_target_index = -1;
var global_align_index = -1;
var global_expecting_select = null;
var global_camera_projection = true;
var global_expected_frame_rate_ms = 66;
var global_use_compass = false;
var global_dso_mag = parseInt(document.getElementById('dso_level_val').innerHTML);

var global_fov = 60;
var global_mag = 4;
var gdata = {
	"lat" : 31.9,
	"lon" : 34.8,
	"compass_alpha" : 0,
	"alpha" : 0,
	"alpha_user_offset" : 0,
	"alpha_gyro" : 0,
	"alpha_diff" : 0,
	"beta" : 0,
	"gamma" : 0,
	"time" : Date.now(), //1614716453109
}

var global_align_matrix = [1,0,0,0,1,0,0,0,1];
var global_use_gyro = false;
var global_full_screen = false;

var global_status = "";

function showStatus(v)
{
	global_status += v+"<br/>"
	document.getElementById('status').innerHTML = global_status;
}

function showConfig(v)
{
	document.getElementById('config').style.display = v;
}
function toggleFS(fs)
{
	if(fs) {
		document.documentElement.requestFullscreen({navigationUI:'hide'});
	}
	else {
		document.exitFullscreen();
	}
}

function incMAG()
{
	if(global_mag < 6)
		global_mag += 1;
	updateMAG()
}
function decMAG()
{
	if(global_mag > 1)
		global_mag -=1;
	updateMAG();
}
function updateMAG()
{
	document.getElementById("mag_val").innerHTML = global_mag + "";
}

function incFOV()
{
	if(global_fov < 150)
		global_fov += 30;
	updateFOV()
}
function decFOV()
{
	if(global_fov > 30)
		global_fov -=30;
	updateFOV();
}
function updateFOV()
{
	document.getElementById("fov_val").innerHTML = global_fov + "&deg;";
}

function setUseGyro(val,message=null)
{
	global_use_gyro = val;
	if(message)
		var status = message;
	else
		var status= global_use_gyro ? "Aligned" : "Not Aligned";
	document.getElementById("alignment").innerHTML = status
}

function resetAll()
{
	global_expecting_select = null;
	global_target_index = -1;
	global_align_index = -1;
	setUseGyro(false);
}

function align()
{
	if(global_expecting_select == doNothing)
		return;
	setUseGyro(false,"Select Star");
	global_align_index = -1;
	global_expecting_select = selectAlignWithTimer;
}

function normV(v)
{
	var len = Math.sqrt(v[0]*v[0]+v[1]*v[1]+v[2]*v[2]);
	return [v[0]/len,v[1]/len,v[2]/len];
}

function matMul(A,B)
{
	var v1 = mvec(A,[B[0],B[3],B[6]]);
	var v2 = mvec(A,[B[1],B[4],B[7]]);
	var v3 = mvec(A,[B[2],B[5],B[8]]);
	return [v1[0],v2[0],v3[0],
		v1[1],v2[1],v3[1],
		v1[2],v2[2],v3[2]];
}

function matAdd(A,alpha,B,beta)
{
	var res = [];
	for(var i=0;i<9;i++) {
		res.push(A[i]*alpha + B[i]*beta);
	}
	return res;
}

function matEye()
{
	return [1,0,0, 0,1,0, 0,0,1];
}

function doNothing(index)
{
}

function selectAlignWithTimer(index,start_val=3)
{
	var cd = document.getElementById("countdown");
	global_align_index = index;
	global_expecting_select = doNothing;
	if(start_val <= 0) {
		cd.innerHTML="";
		selectAlign(index);
	}
	else {
		cd.innerHTML = start_val.toFixed(1) + "s";
		setTimeout(function() {
			selectAlignWithTimer(index,start_val - 0.1);
		},100);
	}
}

function selectAlign(index)
{
	var camRays =  getCameraRays();
	var st = allstars[index];
	var tr = rayFromPos(st.RA,st.DE);
	var fw = camRays[2];
	var left = camRays[1];
	var dAZ = Math.asin(crossProd(normV([tr[0],tr[1],0]),normV([fw[0],fw[1],0]))[2]);
	var dAlt = Math.asin(tr[2]) - Math.asin(fw[2]);
	// rotate around AZ axis
	var daz_mat =  [  Math.cos(dAZ), Math.sin(dAZ), 0,
			 -Math.sin(dAZ), Math.cos(dAZ), 0,
			 0,		 0,		1];
	// rotate around up/dwn - axis of the camera
	var u0 = left[0];
	var u1 = left[1];
	var u2 = left[2];
	var W = [ 0, -u2, u1,   u2, 0, -u0,  -u1, u0, 0 ]
	var dalt_mat = matAdd(matEye(),1,W,Math.sin(-dAlt));
	dalt_mat = matAdd(dalt_mat,1,matMul(W,W),2*Math.sin(-dAlt/2)*Math.sin(-dAlt/2));
	
	//global_align_matrix = daz_mat;
	global_align_matrix = matMul(daz_mat,dalt_mat); 
	
	setUseGyro(true);
	gdata.alpha_diff = (gdata.alpha + gdata.alpha_user_offset) - gdata.alpha_gyro;
	global_align_index = index;
	global_expecting_select = selectTaret;
}

/// rotation matrix is 
/// taken from https://www.w3.org/TR/2016/CR-orientation-event-20160818/#worked-example-2

var degtorad = Math.PI / 180; // Degree-to-Radian conversion


function getRotationMatrix( alpha, beta, gamma ) {

  var _x = beta  ? beta  * degtorad : 0; // beta value
  var _y = gamma ? gamma * degtorad : 0; // gamma value
  var _z = alpha ? alpha * degtorad : 0; // alpha value

  var cX = Math.cos( _x );
  var cY = Math.cos( _y );
  var cZ = Math.cos( _z );
  var sX = Math.sin( _x );
  var sY = Math.sin( _y );
  var sZ = Math.sin( _z );

  //
  // ZXY rotation matrix construction.
  //

  var m11 = cZ * cY - sZ * sX * sY;
  var m12 = - cX * sZ;
  var m13 = cY * sZ * sX + cZ * sY;

  var m21 = cY * sZ + cZ * sX * sY;
  var m22 = cZ * cX;
  var m23 = sZ * sY - cZ * cY * sX;

  var m31 = - cX * sY;
  var m32 = sX;
  var m33 = cX * cY;

  return [
    m11,    m12,    m13,
    m21,    m22,    m23,
    m31,    m32,    m33
  ];

};

function mvec(m,v)
{
	return [ m[0] * v[0] + m[1] * v[1] + m[2] * v[2],
		 m[3] * v[0] + m[4] * v[1] + m[5] * v[2],
		 m[6] * v[0] + m[7] * v[1] + m[8] * v[2] ];
}

function crossProd(a,b)
{
	return [ a[1]*b[2] - a[2]*b[1],
		 a[2]*b[0] - a[0]*b[2],
		 a[0]*b[1] - a[1]*b[0] ];
}

function getCameraRays()
{
	// zxy
	// after Mul comonents are [S,E,D]
	var alpha = global_use_gyro ? gdata.alpha_gyro + gdata.alpha_diff : gdata.alpha + gdata.alpha_user_offset;
	var M = getRotationMatrix(alpha,gdata.beta,gdata.gamma);
	//var top = mvec(M,[1,0,0]);
	//var lft = mvec(M,[0,1,0]);
	//var fwd = mvec(M,[0,0,-1]);
	
	

	var fwd = mvec(M,[0,1,0]);

	// make sure left  is horizontal

	var fwd_hlen = Math.sqrt(fwd[0]*fwd[0] + fwd[1]*fwd[1])
	var fwd_hor = [fwd[0]/fwd_hlen,fwd[1]/fwd_hlen,0.0];

	var lft = [-fwd_hor[1],fwd_hor[0],0.0]
	var top = crossProd(fwd,lft);

	if(global_use_gyro) {
		return [
			mvec(global_align_matrix,top),
			mvec(global_align_matrix,lft),
			mvec(global_align_matrix,fwd)
		];
	}
	else {
		return [top,lft,fwd];
	}
}

function rayFromPos(RAd,DEd)
{
	var deg2rad = Math.PI / 180;
	RA = RAd * deg2rad;
	DE = DEd * deg2rad;
	var jd = gdata.time * 1e-3 / 86400.0 + 2440587.5;
	var tu = jd - 2451545.0;
	var angle = Math.PI * 2 * (0.7790572732640+1.00273781191135448 * tu);
	var q = angle + gdata.lon*deg2rad;
	var H = q - RA;
	
	var f = deg2rad * gdata.lat;

	var az_y = Math.sin(H);
	var az_x = (Math.cos(H) * Math.sin(f) - Math.tan(DE) * Math.cos(f));
	var az = Math.atan2(az_y,az_x)
	var sinH = Math.sin(f) * Math.sin(DE) + Math.cos(f) * Math.cos(DE) * Math.cos(H);
	var hz = Math.asin(sinH)
	var ray_n = -Math.cos(az) * Math.cos(hz);
	var ray_e = -Math.sin(az) * Math.cos(hz);
	var ray_u = Math.sin(hz);
	return [ ray_e, ray_n, ray_u ];
}

function sprod(v1,v2)
{
	return v1[0]*v2[0] + v1[1]*v2[1] + v1[2]*v2[2];
}

function cameraBearing(RAd,DEd,cameraRays)
{
	var ray = rayFromPos(RAd,DEd);
	var top = cameraRays[0];
	var lft = cameraRays[1];
	var fwd = cameraRays[2];
	var x = -sprod(lft,ray);
	var y = sprod(top,ray);
	var z = sprod(fwd,ray);
	return {"x":x,"y":y,"z":z};
}

function getFOV()
{
	var ratio = canvas.width / canvas.height;
	var fov_td,fov_lr;
	if(ratio < 1) {
		fov_td = global_fov;
		fov_lr = fov_td * ratio;
	}
	else {
		fov_lr = global_fov;
		fov_td = fov_lr / ratio;
	}
	return {"lr":fov_lr,"td":fov_td};
}


function xyzTo2d(xyz,in_fov=true)
{
	var deg2rad = Math.PI / 180;
	var fov = getFOV();
	var fov_td = fov.td * deg2rad / 2;
	var fov_lr = fov.lr * deg2rad / 2;
	var x=xyz.x; var y=xyz.y;  var z=xyz.z;

	if(z<=0)
		return null;
	if(global_camera_projection) {
		var lim_x = Math.sin(fov_lr);
		var lim_y = Math.sin(fov_td);
	}
	else {
		x = Math.asin(x);
		y = Math.asin(y)
		var lim_x = fov_lr;
		var lim_y = fov_td;

	}
	if(in_fov) {
		if(x < -lim_x || x > lim_x)
			return null;
		if(y < -lim_y || y > lim_y)
			return null;
	}
	return { x:(x + lim_x) / (lim_x*2), y: 1 - (y + lim_y) / (lim_y * 2) };
}
function projectToCamera(RAd,DEd,cameraRays,in_fov=true)
{
	var xyz = cameraBearing(RAd,DEd,cameraRays)
	return xyzTo2d(xyz,in_fov);
}

function plotStar(star,camRays,highlight)
{
	if(canvas.width != document.body.clientWidth || canvas.height != document.body.clientHeight) {
		canvas.width = document.body.clientWidth;
		canvas.height = document.body.clientHeight;
	}
	
	var pos = projectToCamera(star.RA,star.DE,camRays);
	if(!pos)
		return null;
	context.beginPath();	
	var size = star.t == 'S' ? 6.5 - star.AM : 6 ;
	if(size < 1)
		size = 1;
	var color;
	if(highlight) {
		color = highlight;
		size = 10;
	}
	else {
		color = global_style.star;
	}
	if(star.t == 'S')
		context.fillStyle = color;
	else
		context.fillStyle = 'black';
	var pix_x = pos.x * canvas.width;
	var pix_y = pos.y * canvas.height;
	if(star.t != 'Ca') {
		context.strokeStyle = color;
		context.lineWidth = 1;
		if(star.t == 'Ga') {
			context.ellipse(pix_x,pix_y,size*1.5,size/1.5,Math.PI/4,0,2*Math.PI,false);
			context.fill();
			context.stroke();
			context.beginPath();	
			context.arc(pix_x,pix_y,size/3,0,2*Math.PI,false);
			context.fillStyle = color;
			context.fill();
			context.stroke();
		}
		else if(star.t == 'Gc') {
			context.lineWidth = 2;
			context.setLineDash([1,3])
			context.arc(pix_x,pix_y,size,2*Math.PI,false);
			context.stroke();
			context.beginPath();	
			context.setLineDash([])
			context.fillStyle = color;
			context.arc(pix_x,pix_y,size/3,0,2*Math.PI,false);
			context.fill();
			context.stroke();
		}
		else if(star.t == 'Oc') {
			context.lineWidth = 2;
			context.setLineDash([1,3])
			context.arc(pix_x,pix_y,size,2*Math.PI,false);
			context.stroke();
			context.beginPath();	
			context.setLineDash([1,3])
			context.arc(pix_x,pix_y,size/3,0,2*Math.PI,false);
			context.fill();
			context.stroke();
			context.setLineDash([])
		}
		else if(star.t == 'Ne') {
			context.lineWidth = 1;
			context.moveTo(pix_x - size,pix_y - size);
			var f = 4;
			context.bezierCurveTo(pix_x + f*size,pix_y - size,pix_x -f*size,pix_y + size,pix_x+size,pix_y + size)
			context.stroke();
			context.beginPath();
			context.fillStyle=color;
			context.arc(pix_x,pix_y,size/3,0,2*Math.PI,false);
			context.fill();
			context.stroke();
		}
		else {
			context.arc(pix_x,pix_y,size,0,2*Math.PI,false);
			context.fill();
			context.stroke();
		}
	}
	if(star.name) {
		if(star.t == 'Ca') {
			color = global_style.constelations;
		}
		context.strokeStyle = color;
		context.fillStyle = color;
		if(star.t == 'Ca') {
			context.font = "4mm Sans"
			context.textBaseline = 'middle';
			context.textAlign = 'center';
			context.fillText(star.name,pix_x,pix_y)
		}
		else {
			context.font = "3mm Sans";
			context.textBaseline = 'bottom';
			context.textAlign = 'start';
			context.fillText(star.name,pix_x + size + 1,pix_y - size - 1)
		}
	}
	return { x: pix_x, y:pix_y , index:-1};
}

function plotLines(camRays)
{
	if(!global_show_obj.Ca)
		return;
	for(var i=0;i<constellation_lines.length;i++) {
		line = constellation_lines[i];
		var p1 = projectToCamera(line.r0,line.d0,camRays,false);
		var p2 = projectToCamera(line.r1,line.d1,camRays,false);
		if(!p1 || !p2)
			continue;
		context.beginPath();	
		context.strokeStyle = global_style.constelations;
		context.lineWidth = 1;
		context.moveTo(p1.x*canvas.width,p1.y*canvas.height);
		context.lineTo(p2.x*canvas.width,p2.y*canvas.height);
		context.stroke();
	}
}


function plotCross()
{
	context.strokeStyle = global_style.cross;
	context.fillStyle = global_style.cross;
	context.lineWidth = 3;
	var dirs = [[1,0],[0,1],[-1,0],[0,-1]];
	var length = 50;
	var offset =10;
	for(var i=0;i<dirs.length;i++) {
		context.moveTo(canvas.width/2 + offset*dirs[i][0],canvas.height/2 + offset*dirs[i][1]);
		context.lineTo(canvas.width/2 + length*dirs[i][0],canvas.height/2 + length*dirs[i][1]);
	}
	context.stroke();
}

function plotBearing(xyz)
{
	context.beginPath();
	context.strokeStyle = global_style.bearing;
	context.fillStyle = global_style.bearing;
	context.lineWidth = 5;
	context.arc(canvas.width/2,canvas.height/2,10,0,2*Math.PI,false);
	context.moveTo(canvas.width/2,canvas.height/2);
	var dx = xyz.x;
	var dy = -xyz.y;
	var r = 1 / Math.sqrt(dx*dx+dy*dy);
	dx = dx*r;
	dy = dy*r;
	var length = 100;
	var pos = xyzTo2d(xyz);
	if(pos) {
		var px = canvas.width * (pos.x - 0.5); 
		var py = canvas.height * (pos.y - 0.5);
		var dist = Math.sqrt(px*px + py*py);
		if(dist < length)
			length = dist;
	}
	context.lineTo(canvas.width/2 + dx * length,canvas.height/2 + dy * length);
	var updn = (dy > 0 ? 'Down' : 'Up' ) + ' ' + Math.abs(Math.atan2(-xyz.y,xyz.z) / Math.PI * 180).toFixed(1) + '\u00b0';
	var left = (dx > 0 ? 'Right' : 'Left' ) + ' ' + Math.abs(Math.atan2(xyz.x,xyz.z) / Math.PI * 180).toFixed(1) + '\u00b0';
	context.stroke();
	context.lineWidth = 0;
	context.font = "6mm Serif";
	context.strokeStyle = global_style.bearing;
	context.fillStyle = global_style.bearing;
	context.textBaseline = 'middle';
	context.textAlign = 'end';
	context.fillText(updn,canvas.width - 5,canvas.height / 2)
	context.textAlign = 'center';
	context.textBaseline = 'bottom';
	context.fillText(left,canvas.width/2,canvas.height - 5)
}			


function logObject(thestar)
{
	if(thestar.name == 'Sirius' || thestar.name == 'Mars' || thestar.name == 'Jupiter' || thestar.name == 'Rigel') {
		document.getElementById('object_log').style.display='inline';
		if(1) {
			let ray = rayFromPos(thestar.RA,thestar.DE);
			let alt = Math.asin(ray[2]) / Math.PI * 180
				let az  = Math.atan2(ray[0],ray[1]) / Math.PI * 180;
			if(az < 0)
				az += 360;
			formatLatLon(thestar.name+"_alt",alt,'+','-');
			formatLatLon(thestar.name+"_az",az,'+','-');
		}
		else{
			let alt = thestar.RA / 15;
			let az  = thestar.DE;
			formatLatLon(thestar.name+"_alt",alt,'','-');
			formatLatLon(thestar.name+"_az",az,'+','-');
		}
	}
}

function getSolarSystemObject(p)
{
	var body = astrolib.bodies.indexOf(p);
	var r2d = 180 / Math.PI;
	var d2r = Math.PI / 180;
	var rLat = gdata.lat * d2r;
	var rLon = gdata.lon * d2r;
	var jd = astrolib.convertDateToJulianDate(new Date());
	var RaDec = astrolib.getBodyRaDec(jd,body,rLat,rLon,false);
	var RA = RaDec[2];
	var DEC = RaDec[1];
	return { "RA" : RA * r2d, "DE": DEC *r2d, "name": p, "AM" : -1 };
}



function plotStars()
{
	var start=Date.now();
	global_targets_list=[];
	gdata.time = Date.now();
	var camRays = getCameraRays();
	context.fillStyle = "black";
	context.fillRect(0, 0, canvas.width, canvas.height);
	context.fillStyle = global_style.star;

	for(var i=0;i<allstars.length;i++) {
		var st = allstars[i].t;
		
		if(st == 'P') {
		    let pos = getSolarSystemObject(allstars[i].name);
		    allstars[i].RA = pos.RA;
		    allstars[i].DE = pos.DE;
		}
		
		//logObject(allstars[i]);
		
		var mag = allstars[i].AM;
		if((st == 'S' && mag > global_mag) || (st != 'S' && mag > global_dso_mag) || !global_show_obj[st])
		{
			i=allstars_index[st] - 1;
			continue
		}
		var highlight = null;
		if(i == global_target_index)
			highlight = global_style.target;
		else if(i == global_align_index)
			highlight = global_style.align;
		var  pos = plotStar(allstars[i],camRays,highlight);
		// select only stars if not aligned
		// if aligned select all but constellations
		if(pos && st!='Ca' && (st == 'S' || global_use_gyro)) {
			pos.index = i;
			global_targets_list.push(pos);
		}
	}
	if(global_target_index >= 0) {
		var star = allstars[global_target_index];
		var xyz = cameraBearing(star.RA,star.DE,camRays);
		plotBearing(xyz);

	}
	else if(global_use_gyro) {
		plotCross();
	}
	plotLines(camRays);
	plotAltAz(camRays[2]);
	var passed = Date.now() - start;
	if(passed > global_expected_frame_rate_ms / 2) {
		setTimeout(plotStars,global_expected_frame_rate_ms);
	}
	else {
		setTimeout(plotStars,global_expected_frame_rate_ms-passed);
	}
}


function plotAltAz(fwd)
{
	var alt = Math.asin(fwd[2]) / Math.PI * 180;
	var az  = Math.atan2(fwd[0],fwd[1]) / Math.PI * 180;
	alt = 'Alt:' + alt.toFixed(1);
	if(az < 0)
		az = 360 + az;
	az  = 'Az:' + az.toFixed(1);
	context.font = "5mm Sans"
	context.textBaseline = 'bottom';
	context.textAlign = 'end';
	context.fillStyle = global_style.altaz;
	context.fillText(alt,canvas.width - 5,canvas.height - 5)
	context.textAlign = 'start';
	context.fillText(az,5,canvas.height - 5)
}

function selectTaret(index)
{
	global_target_index = index;
	//global_expecting_select = null;
}

function selectionEvent(e)
{
	let x = e.clientX;
	let y = e.clientY;
	let min_dist = 1e100;
	let min_index = -1;
	for(var i=0;i<global_targets_list.length;i++) {
		let dx = global_targets_list[i].x - x;
		let dy = global_targets_list[i].y - y;
		let dist = dx*dx + dy*dy;
		if(min_dist > dist) {
			min_dist = dist;
			min_index = global_targets_list[i].index;
		}
	}
	if(global_expecting_select) {
		global_expecting_select(min_index);
	}
}

function formatLatLon(id,deg,pos,neg)
{
	var direction = deg >= 0 ? pos : neg;
	deg = Math.abs(deg);
	var ideg = Math.floor(deg);
	var min = 60*(deg - ideg);
	var imin = Math.floor(min);
	var sec = 60*(min - imin);
	var msg = direction + ideg + "\u00b0" + imin + "'" + sec.toFixed(1) + "''";
	document.getElementById(id).innerHTML = msg;
}

function showpos(position)
{
	var latlon = position.coords.latitude + "," + position.coords.longitude;
	gdata.lat = position.coords.latitude;
	gdata.lon = position.coords.longitude;
	formatLatLon("lat",gdata.lat,'N','S');
	formatLatLon("lon",gdata.lon,'E','W');
	document.getElementById("gps").style.display='none';
}

function getLocation() {
  if (navigator.geolocation) {
    navigator.geolocation.getCurrentPosition(showpos);
  }
  setTimeout(getLocation,600*1000)
}

function gyroListener(event)
{
	if(!(event.alpha === null)) {
		gdata.alpha_gyro = event.alpha;
		gdata.beta = event.beta;
		gdata.gamma = event.gamma;
		document.getElementById("orient").innerHTML = '';
	}
	else {
		document.getElementById("orient").innerHTML = 'No Gyro';
	}
	formatValue("ang_a",event.alpha);
	formatValue("ang_b",event.beta);
	formatValue("ang_g",event.gamma);
}

function deviceOrientationListenerIOS(event) {
	if(!(event.webkitCompassHeading === null)) {
		if(global_use_compass)
			gdata.alpha = event.webkitCompassHeading;
		gdata.compass_alpha = event.webkitCompassHeading;
	}
	else {
		noCompass();
	}
	formatValue("ang_c",event.webkitCompassHeading);
}

function deviceOrientationListener(event) {
	if(!(event.alpha === null)) {
		if(global_use_compass)
			gdata.alpha = event.alpha;
		gdata.compass_alpha = event.alpha;
	}
	else {
		noCompass();
	}
	formatValue("ang_c",event.alpha);
}


function noCompass()
{
	global_use_compass = false;
	document.getElementById("nocompass_button").style.display="inline";
	document.getElementById("compass_button").style.display="none";
	document.getElementById("hand_button").style.display="none";
}

function manualMode()
{
	global_use_compass = false;
	gdata.alpha_user_offset = gdata.alpha;
	gdata.alpha = 0;
	document.getElementById("compass_button").style.display="inline";
	document.getElementById("hand_button").style.display="none";
}

function compassMode()
{
	global_use_compass = true;
	gdata.alpha_user_offset = 0;
	gdata.alpha = gdata.compass_alpha;
	document.getElementById("compass_button").style.display="none";
	document.getElementById("hand_button").style.display="inline";
}

function manualDown(e)
{
	global_prev_xy = {"x":e.touches[0].clientX,"y":e.touches[0].clientY };
}

function manualMove(e)
{
	if(!global_prev_xy)
		return;
	
	var xy = {"x":e.touches[0].clientX,"y":e.touches[0].clientY };
	moveSky(global_prev_xy,xy);
	global_prev_xy = xy;
}
function manualUp(e)
{
	if(!global_prev_xy)
		return;
	var xy = {"x":e.touches[0].clientX,"y":e.touches[0].clientY };
	moveSky(global_prev_xy,xy);
	global_prev_xy = null;
}
function moveSky(prev,cur)
{
	if(global_use_compass)
		return;
	if(!prev || !cur)
		return;
	var fov =  getFOV().lr;
	var da = (cur.x - prev.x) / canvas.width * fov;;
	gdata.alpha_user_offset += da;
}

function dontPropMouseDown(lst)
{
	for(var i=0;i<lst.length;i++) {
		var elements = document.getElementsByClassName(lst[i]);
		for(var j=0;j<elements.length;j++) {
			elements[j].addEventListener('mousedown',function(e) {
				e.stopPropagation();
			});
		}
	}
}



function setupiOSOrientationEvents()
{
	if (window.DeviceOrientationEvent) {
		if(('ondeviceorientation' in window)) {
			window.addEventListener("deviceorientation", deviceOrientationListenerIOS);
			window.addEventListener("deviceorientation",gyroListener);
			compassMode();
		}
		else {
			unsupported();
		}
	} else {
		unsupported();
	}
	setUseGyro(false);
}


function setupOrientationEvents()
{
	if (window.DeviceOrientationEvent) {
		if(('ondeviceorientationabsolute' in window)) {
			window.addEventListener("deviceorientationabsolute", deviceOrientationListener);
			window.addEventListener("deviceorientation",gyroListener);
			compassMode();
		}
		else if(('ondeviceorientation' in window)) {
			window.addEventListener("deviceorientation",gyroListener);
			noCompass();
		}
		else {
			unsupported();
		}
	} else {
		unsupported();
	}
	setUseGyro(false);
}

function formatValue(uid,v)
{
	var msg='';
	if(v === undefined || v==null) {
		msg = 'No';
	}
	else {
		msg = v.toFixed(1);
	}
	document.getElementById(uid).innerHTML=msg;
}


function iOSOrientation()
{
	//Notification.requestPermission().then(response => {
	DeviceOrientationEvent.requestPermission().then(response => {
		if (response == 'granted') {
			document.getElementById("allow_orientation").style.display='none';
			setupiOSOrientationEvents();
		}
	})
	.catch(console.error)
}

function setupGyros()
{
	//if (typeof window.Notification.requestPermission === 'function') {
	if (typeof window.DeviceOrientationEvent.requestPermission === 'function') {
		document.getElementById("allow_orientation").style.display='inline';
	}
	else {
		setupOrientationEvents();
	}
}

function switchNightMode(is_night)
{
	global_style = is_night ? global_night_style : global_day_style;
}


function setDSOMag(val)
{
	global_dso_mag = parseInt(val);
	document.getElementById('dso_level_val').innerHTML = '' + global_dso_mag;
}

setupGyros();
// global drawing stuff
var canvas = document.getElementById('myCanvas');
canvas.width = document.body.clientWidth;
canvas.height = document.body.clientHeight;
var context = canvas.getContext('2d');
setTimeout(getLocation,500)
setTimeout(plotStars,1000)
document.body.addEventListener('mousedown',selectionEvent);
document.body.addEventListener('touchstart',manualDown);
document.body.addEventListener('touchend',manualUp);
document.body.addEventListener('touchcancel',manualUp);
document.body.addEventListener('touchmove',manualMove);
dontPropMouseDown(["ui_but","incdec_but","config_div","comp_but"]);
</script>


</body>
</html>
